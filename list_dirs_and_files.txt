--- Directory Tree Structure ---
```
|-- .mypy_cache
|-- build
|-- dist
|-- docs

```
--- File List and Contents ---
```
File: D:\Projects\bling_monitor\dump_products.py
import json
import os
import requests
import time

API_BASE = "https://api.bling.com.br/Api/v3"
OUTPUT_FILE = "products_dump.json"

def get_all_categories(access_token):
    headers = {"Authorization": f"Bearer {access_token}"}
    all_categories = {}
    page = 1
    while True:
        url = f"{API_BASE}/categorias/produtos?pagina={page}&limite=100"
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        data = response.json()
        categories = data.get("data", [])
        if not categories:
            break
        for cat in categories:
            all_categories[cat['id']] = cat
        page += 1
    print(f"Found {len(all_categories)} categories.")
    return all_categories

def get_category_prefix(category_name):
    parts = category_name.split()
    if len(parts) > 1:
        return (parts[0][:2] + parts[1][:2]).upper()
    else:
        return category_name[:4].upper()

def dump_all_products(access_token):
    headers = {"Authorization": f"Bearer {access_token}"}
    
    print("Fetching all categories...")
    categories = get_all_categories(access_token)
    category_counters = {}
    category_prefixes = {}

    all_products = []
    page = 1

    while True:
        url = f"{API_BASE}/produtos?pagina={page}&limite=100"
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        data = response.json()

        products = data.get("data", [])
        if not products:
            break

        for product_summary in products:
            product_id = product_summary["id"]
            details_url = f"{API_BASE}/produtos/{product_id}"
            details_response = requests.get(details_url, headers=headers)
            details_response.raise_for_status()
            product_details = details_response.json().get("data", {})

            if 'categoria' not in product_details:
                continue

            if not product_details['codigo'] and product_details['categoria']['id'] in categories:
                cat_id = product_details['categoria']['id']
                cat = categories[cat_id]
                
                cat_name = cat_name['nome']
                if cat_id not in category_counters:
                    category_counters[cat_id] = 0
                
                if cat_id not in category_prefixes:
                    category_prefixes[cat_id] = get_category_prefix(cat_name)

                category_counters[cat_id] += 1
                prefix = category_prefixes[cat_id]
                counter = category_counters[cat_id]
                
                product_details['codigo'] = f"{prefix}{counter:05d}"
            
            all_products.append(product_details)
            time.sleep(0.4)

        print(f"Fetched page {page}, total so far: {len(all_products)}")
        page += 1

    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        json.dump(all_products, f, ensure_ascii=False, indent=2)

    print(f"\nâœ… Dump saved to {OUTPUT_FILE} ({len(all_products)} products)")

if __name__ == "__main__":
    TOKEN_FILE = "tokens.json"
    if not os.path.exists(TOKEN_FILE):
        print(f"Error: Token file '{TOKEN_FILE}' not found.")
        print("Please run test.py first to generate the tokens.")
    else:
        with open(TOKEN_FILE, 'r') as f:
            try:
                tokens = json.load(f)
                access_token = tokens.get('access_token')
                if not access_token:
                    print("Error: Access token not found in tokens.json.")
                else:
                    dump_all_products(access_token)
            except json.JSONDecodeError:
                print(f"Error: Could not decode JSON from {TOKEN_FILE}.")
```

```
File: D:\Projects\bling_monitor\test.py
import requests
import base64
import json
import os
import time # Import the time module
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# --- Configuration ---
CLIENT_ID = os.getenv("CLIENT_ID")
CLIENT_SECRET = os.getenv("CLIENT_SECRET")
REDIRECT_URI = os.getenv("REDIRECT_URI")
# You will only need this AUTH_CODE for the very first run.
AUTH_CODE = os.getenv("AUTH_CODE")
MINUTES_BETWEEN_RUNS = int(os.getenv("MINUTES_BETWEEN_RUNS", 5)) # Default to 5 minutes

TOKEN_URL = "https://www.bling.com.br/Api/v3/oauth/token"
API_BASE = "https://www.bling.com.br/Api/v3"


TOKEN_FILE = "tokens.json"

# --- Global State ---
access_token = None
refresh_token = None

# --- Helper Functions ---
def get_basic_auth_header():
    """Encodes Client ID and Secret for Basic Auth."""
    auth_string = f"{CLIENT_ID}:{CLIENT_SECRET}"
    encoded_auth = base64.b64encode(auth_string.encode()).decode()
    return {
        "Authorization": f"Basic {encoded_auth}",
        "Content-Type": "application/x-www-form-urlencoded"
    }

def save_tokens(tokens):
    """Saves access and refresh tokens to a file."""
    global access_token, refresh_token
    access_token = tokens['access_token']
    refresh_token = tokens['refresh_token']
    with open(TOKEN_FILE, 'w') as f:
        json.dump(tokens, f)
    print("Tokens saved successfully.")

def load_tokens():
    """Loads tokens from a file if it exists."""
    if not os.path.exists(TOKEN_FILE):
        return None
    with open(TOKEN_FILE, 'r') as f:
        try:
            return json.load(f)
        except json.JSONDecodeError:
            return None

# --- API Authentication ---
def get_initial_token():
    """Exchanges the one-time AUTH_CODE for the first token."""
    print("Attempting to get initial token with AUTH_CODE...")
    data = {
        "grant_type": "authorization_code",
        "redirect_uri": REDIRECT_URI,
        "code": AUTH_CODE
    }
    headers = get_basic_auth_header()
    response = requests.post(TOKEN_URL, headers=headers, data=data)
    response.raise_for_status()
    tokens = response.json()
    save_tokens(tokens)
    return tokens

def refresh_access_token():
    """Refreshes the access token using the stored refresh token."""
    print("Refreshing access token...")
    global refresh_token
    if not refresh_token:
        raise ValueError("No refresh token available.")
        
    data = {
        "grant_type": "refresh_token",
        "refresh_token": refresh_token
    }
    headers = get_basic_auth_header()
    response = requests.post(TOKEN_URL, headers=headers, data=data)
    response.raise_for_status()
    tokens = response.json()
    # Bling might not always return a new refresh token, so we preserve the old one.
    if 'refresh_token' not in tokens:
        tokens['refresh_token'] = refresh_token
    save_tokens(tokens)
    return tokens

# --- API Core Logic ---
def get_products(page=1):
    """Fetches a paginated list of products from the Bling API."""
    headers = {"Authorization": f"Bearer {access_token}"}
    url = f"{API_BASE}/produtos?pagina={page}&limite=100"
    response = requests.get(url, headers=headers)
    
    if response.status_code == 401:  # Token expired
        print("Access token expired. Refreshing...")
        refresh_access_token()
        headers = {"Authorization": f"Bearer {access_token}"} # Retry with new token
        response = requests.get(url, headers=headers)
        
    response.raise_for_status()
    return response.json()

def update_product(product_id, payload):
    """Updates a product's information on the Bling API."""
    headers = {"Authorization": f"Bearer {access_token}", "Content-Type": "application/json"}
    url = f"{API_BASE}/produtos/{product_id}"
    response = requests.patch(url, headers=headers, data=json.dumps(payload))

    if response.status_code == 401:  # Token expired
        print("Access token expired. Refreshing...")
        refresh_access_token()
        headers = {"Authorization": f"Bearer {access_token}", "Content-Type": "application/json"} # Retry with new token
        response = requests.patch(url, headers=headers, data=json.dumps(payload))
        
    response.raise_for_status()
    return response.json()

def find_and_deactivate_first_zero_stock_product():
    """Finds the first product with zero stock and sets its status to 'Inativo'."""
    print("\nSearching for the first product with zero stock to deactivate...")
    page = 1
    count = 0
    while True:
        if count > 100:
            return #Deal with 100 itens, then returns

        try:
            data = get_products(page)
            products = data.get("data", [])
            if not products:
                print("No more products to check.")
                break
            
            for p in products:
                stock = p.get("estoqueAtual", 0)
                if stock == 0:
                    product_id = p.get("id")
                    product_name = p.get("nome")
                    print(f"Found product with zero stock - ID: {product_id} | Name: {product_name}. Deactivating...")
                    
                    # Payload to set product status to 'Desativado'
                    payload = {"situacao": "I"}
                    update_product(product_id, payload)
                    print(f"Product ID: {product_id} | Name: {product_name} has been set to Inativo.")
            
            page += 1
        except requests.exceptions.HTTPError as e:
            print(f"An API error occurred: {e}")
            break
        count += 1
# --- Main Execution ---
if __name__ == "__main__":
    try:
        while True:
            loaded_tokens = load_tokens()
            if loaded_tokens:
                refresh_token = loaded_tokens['refresh_token']
                try:
                    refresh_access_token()
                except requests.exceptions.HTTPError as e:
                    print(f"Failed to refresh token: {e}. Please get a new AUTH_CODE.")
                    # As a fallback, you could delete tokens.json and re-run
            else:
                try:
                    get_initial_token()
                except requests.exceptions.HTTPError as e:
                    print(f"Failed to get initial token: {e}")
                    print("Please ensure your AUTH_CODE is new and valid.")

            if access_token:
                find_and_deactivate_first_zero_stock_product()
            else:
                print("\nCould not obtain access token. Exiting.")
            
            print(f"\nWaiting for {MINUTES_BETWEEN_RUNS} minutes before next run...")
            time.sleep(MINUTES_BETWEEN_RUNS * 60) # Convert minutes to seconds

    except KeyboardInterrupt:
        print("\nScript interrupted by user. Exiting.")
```


