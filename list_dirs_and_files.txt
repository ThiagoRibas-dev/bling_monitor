--- Directory Tree Structure ---
```
|-- .mypy_cache
|-- .ruff_cache
|-- build
|   |-- test
|-- dist
|-- docs
|-- __pycache__

```

--- File List and Contents ---
```
File: D:\Projects\bling_monitor\.env.example
# Credenciais Bling API
CLIENT_ID=seu_client_id_aqui
CLIENT_SECRET=seu_client_secret_aqui
REDIRECT_URI=https://sua-vps.com/callback
AUTH_CODE=codigo_obtido_na_primeira_execucao

# Configurações de execução
MINUTES_BETWEEN_RUNS=60

# Webhook
WEBHOOK_PORT=5000

# Database (opcional)
DATABASE_PATH=bling_data.db

```

```
File: D:\Projects\bling_monitor\.env.prod
# Credenciais Bling API
CLIENT_ID="bbe833b0ccf6d38605f196b8504763f8bf549a4d"
CLIENT_SECRET="5cae81f3634b69c33ba73727376acef9417fa1e552d5bd40bf075c8fb016"
REDIRECT_URI="https://localhost/"

# Quantidade de minutos entre as execições do processo
MINUTES_BETWEEN_RUNS=5

# Este Auth Code expira. Caso a aplicação pare de funcionar dando Erro 400, 401, etc, 
# é necessario acessar logar no bling.com.br, acessar o endereço  
# https://www.bling.com.br/Api/v3/oauth/authorize?response_type=code&client_id=bbe833b0ccf6d38605f196b8504763f8bf549a4d&state=50473fc7a76bbb5fd37831e32aac717f
# e pegar o valor do code no endereço resultante.
# Por exemplo, acessamos o endereço e o navegador redireciona para 
# https://localhost/?code=d3d41dda63c4f22689c6e4770f39f821c992064c&state=50473fc7a76bbb5fd37831e32aac717f
# pegamos o codigo d3d41dda63c4f22689c6e4770f39f821c992064c e colocamos na variavel AUTH_CODE entre aspas duplas
AUTH_CODE="3b631b88b767aa72b5aa2b25103f2fe8d0e8d5e6"

# Configurações de execução
MINUTES_BETWEEN_RUNS=60

# Webhook
WEBHOOK_PORT=5000

# Database (opcional)
DATABASE_PATH=bling_data.db

```

```
File: D:\Projects\bling_monitor\bling_api.py
"""
Cliente API Bling com retry, rate limiting e tratamento de erros
"""
import requests
import time
from collections import deque
from datetime import datetime, timedelta


class RateLimiter:
    """Controla rate limit de 3 req/s e 120k/dia."""
    
    def __init__(self, requests_per_second=3, requests_per_day=120000):
        self.rps = requests_per_second
        self.rpd = requests_per_day
        
        # Janela deslizante para req/s
        self.second_window = deque()
        
        # Contador diário
        self.daily_count = 0
        self.daily_reset = datetime.now() + timedelta(days=1)
    
    def wait_if_needed(self):
        """Aguarda se necessário para respeitar limites."""
        now = time.time()
        
        # Reset contador diário se necessário
        if datetime.now() >= self.daily_reset:
            self.daily_count = 0
            self.daily_reset = datetime.now() + timedelta(days=1)
            print("📊 Rate limit diário resetado")
        
        # Verifica limite diário
        if self.daily_count >= self.rpd:
            wait_seconds = (self.daily_reset - datetime.now()).total_seconds()
            print(f"⚠️ Limite diário atingido! Aguardando {wait_seconds/3600:.1f} horas...")
            time.sleep(wait_seconds)
            self.daily_count = 0
        
        # Remove requisições antigas da janela (>1s)
        while self.second_window and now - self.second_window[0] > 1:
            self.second_window.popleft()
        
        # Se atingiu limite por segundo, aguarda
        if len(self.second_window) >= self.rps:
            sleep_time = 1 - (now - self.second_window[0])
            if sleep_time > 0:
                time.sleep(sleep_time)
        
        # Registra requisição
        self.second_window.append(time.time())
        self.daily_count += 1


class BlingAPI:
    """Cliente HTTP para API Bling com retry e rate limiting."""
    
    BASE_URL = "https://api.bling.com.br/Api/v3"
    
    def __init__(self, get_token_func):
        """
        Args:
            get_token_func: Função que retorna access token válido
        """
        self.get_token = get_token_func
        self.rate_limiter = RateLimiter()
    
    def _headers(self):
        """Retorna headers com token atual."""
        return {
            "Authorization": f"Bearer {self.get_token()}",
            "Content-Type": "application/json"
        }
    
    def _request(self, method, endpoint, max_retries=3, **kwargs):
        """
        Faz requisição com retry automático e exponential backoff.
        
        Args:
            method: GET, POST, PATCH, DELETE
            endpoint: Ex: "/produtos" ou "/produtos/123"
            max_retries: Número máximo de tentativas
            **kwargs: Argumentos para requests (params, json, data)
        """
        url = f"{self.BASE_URL}/{endpoint.lstrip('/')}"
        
        for attempt in range(max_retries):
            try:
                # Rate limiting
                self.rate_limiter.wait_if_needed()
                
                # Fazer requisição
                response = requests.request(
                    method,
                    url,
                    headers=self._headers(),
                    timeout=30,
                    **kwargs
                )
                
                # Tratar erros HTTP
                if response.status_code == 401:
                    # Token expirado, força refresh e tenta de novo
                    print("⚠️ Token expirado (401), tentando refresh...")
                    from bling_auth import refresh_access_token
                    refresh_access_token()
                    # Retry com novo token (não conta como tentativa)
                    continue
                
                elif response.status_code == 429:
                    # Rate limit excedido
                    retry_after = int(response.headers.get('Retry-After', 60))
                    print(f"⏳ Rate limit (429). Aguardando {retry_after}s...")
                    time.sleep(retry_after)
                    continue
                
                elif response.status_code >= 500:
                    # Erro do servidor, retry com backoff
                    if attempt < max_retries - 1:
                        wait = 2 ** attempt  # 1s, 2s, 4s
                        print(f"⚠️ Erro {response.status_code}. Retry {attempt+1}/{max_retries} em {wait}s...")
                        time.sleep(wait)
                        continue
                
                # Verificar sucesso
                response.raise_for_status()
                
                # Retornar JSON ou dict vazio
                return response.json() if response.content else {}
            
            except requests.exceptions.Timeout:
                if attempt < max_retries - 1:
                    wait = 2 ** attempt
                    print(f"⏱️ Timeout. Retry {attempt+1}/{max_retries} em {wait}s...")
                    time.sleep(wait)
                    continue
                raise
            
            except requests.exceptions.RequestException as e:
                if attempt < max_retries - 1:
                    wait = 2 ** attempt
                    print(f"⚠️ Erro de rede: {e}. Retry {attempt+1}/{max_retries} em {wait}s...")
                    time.sleep(wait)
                    continue
                raise
        
        raise Exception(f"Falhou após {max_retries} tentativas")
    
    # === Produtos ===
    
    def get_products(self, page=1, limit=100, **filters):
        """Lista produtos com paginação."""
        params = {"pagina": page, "limite": limit, **filters}
        return self._request("GET", "/produtos", params=params)
    
    def get_product(self, product_id):
        """Obtém detalhes de um produto."""
        return self._request("GET", f"/produtos/{product_id}")
    
    def update_product(self, product_id, data):
        """Atualiza produto (PATCH)."""
        import json
        return self._request("PATCH", f"/produtos/{product_id}", data=json.dumps(data))
    
    def update_product_situation(self, product_id, situation):
        """
        Atualiza situação do produto.
        situation: 'A' (Ativo) ou 'I' (Inativo)
        """
        import json
        return self._request(
            "PATCH",
            f"/produtos/{product_id}/situacoes",
            data=json.dumps({"situacao": situation})
        )
    
    # === Categorias ===
    
    def get_categories(self, page=1, limit=100):
        """Lista categorias."""
        params = {"pagina": page, "limite": limit}
        return self._request("GET", "/categorias/produtos", params=params)
    
    def get_all_categories(self):
        """Obtém todas as categorias (auto-paginação)."""
        all_cats = {}
        page = 1
        
        while True:
            data = self.get_categories(page=page, limit=100)
            cats = data.get("data", [])
            
            if not cats:
                break
            
            for cat in cats:
                all_cats[cat['id']] = cat
            
            page += 1
        
        print(f"📦 {len(all_cats)} categorias carregadas")
        return all_cats
    
    # === Estoque ===
    
    def get_stock_movements(self, product_id, start_date=None, end_date=None):
        """
        Obtém movimentações de estoque de um produto.
        
        Args:
            product_id: ID do produto
            start_date: Data inicial (formato YYYY-MM-DD)
            end_date: Data final (formato YYYY-MM-DD)
        """
        params = {"idProduto": product_id}
        if start_date:
            params['dataInicial'] = start_date
        if end_date:
            params['dataFinal'] = end_date
        
        return self._request("GET", "/estoques", params=params)
    
    # === Pedidos ===
    
    def get_orders(self, page=1, limit=100, **filters):
        """Lista pedidos de venda."""
        params = {"pagina": page, "limite": limit, **filters}
        return self._request("GET", "/pedidos/vendas", params=params)

```

```
File: D:\Projects\bling_monitor\bling_auth.py
"""
Módulo compartilhado para autenticação OAuth com Bling
Elimina duplicação de código entre test.py e dump_products.py
"""
import requests
import base64
import json
import os
from dotenv import load_dotenv

load_dotenv()

# Configurações
CLIENT_ID = os.getenv("CLIENT_ID")
CLIENT_SECRET = os.getenv("CLIENT_SECRET")
REDIRECT_URI = os.getenv("REDIRECT_URI")
TOKEN_URL = "https://www.bling.com.br/Api/v3/oauth/token"
TOKEN_FILE = "tokens.json"

# Estado global
_tokens = None


def get_basic_auth_header():
    """Encodes Client ID and Secret for Basic Auth."""
    auth_string = f"{CLIENT_ID}:{CLIENT_SECRET}"
    encoded_auth = base64.b64encode(auth_string.encode()).decode()
    return {
        "Authorization": f"Basic {encoded_auth}",
        "Content-Type": "application/x-www-form-urlencoded"
    }


def save_tokens(tokens):
    """Saves access and refresh tokens to a file."""
    global _tokens
    _tokens = tokens
    with open(TOKEN_FILE, 'w') as f:
        json.dump(tokens, f, indent=2)
    print("✅ Tokens saved successfully.")


def load_tokens():
    """Loads tokens from a file if it exists."""
    global _tokens
    if not os.path.exists(TOKEN_FILE):
        return None
    try:
        with open(TOKEN_FILE, 'r') as f:
            _tokens = json.load(f)
            return _tokens
    except json.JSONDecodeError:
        return None


def get_initial_token(auth_code):
    """Exchanges the one-time AUTH_CODE for the first token."""
    print("🔑 Attempting to get initial token with AUTH_CODE...")
    data = {
        "grant_type": "authorization_code",
        "redirect_uri": REDIRECT_URI,
        "code": auth_code
    }
    headers = get_basic_auth_header()
    response = requests.post(TOKEN_URL, headers=headers, data=data)
    response.raise_for_status()
    tokens = response.json()
    save_tokens(tokens)
    return tokens


def refresh_access_token():
    """Refreshes the access token using the stored refresh token."""
    global _tokens
    
    if not _tokens:
        _tokens = load_tokens()
    
    if not _tokens or 'refresh_token' not in _tokens:
        raise ValueError("No refresh token available. Run with AUTH_CODE first.")
    
    print("🔄 Refreshing access token...")
    data = {
        "grant_type": "refresh_token",
        "refresh_token": _tokens['refresh_token']
    }
    headers = get_basic_auth_header()
    response = requests.post(TOKEN_URL, headers=headers, data=data)
    response.raise_for_status()
    
    new_tokens = response.json()
    # Preserve refresh token if not returned
    if 'refresh_token' not in new_tokens:
        new_tokens['refresh_token'] = _tokens['refresh_token']
    
    save_tokens(new_tokens)
    return new_tokens


def get_access_token():
    """Returns a valid access token, refreshing if necessary."""
    global _tokens
    
    if not _tokens:
        _tokens = load_tokens()
    
    if not _tokens:
        auth_code = os.getenv("AUTH_CODE")
        if not auth_code:
            raise ValueError("No tokens found and no AUTH_CODE in .env")
        return get_initial_token(auth_code)['access_token']
    
    # Try to use current token, refresh if it fails (lazy refresh)
    return _tokens['access_token']


def ensure_authenticated():
    """Ensures valid authentication, returns access token."""
    try:
        return get_access_token()
    except Exception as e:
        print(f"❌ Error: {e}")
        print("🔄 Attempting to refresh token...")
        return refresh_access_token()['access_token']

```

```
File: D:\Projects\bling_monitor\bling_db.py
"""
Módulo de persistência SQLite para contadores de código e cache
"""
import sqlite3
import json
from datetime import datetime
from contextlib import contextmanager


class BlingDatabase:
    def __init__(self, db_path="bling_data.db"):
        self.db_path = db_path
        self._init_db()
    
    @contextmanager
    def _get_connection(self):
        """Context manager para conexões SQLite."""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row  # Permite acessar colunas por nome
        try:
            yield conn
            conn.commit()
        except Exception:
            conn.rollback()
            raise
        finally:
            conn.close()
    
    def _init_db(self):
        """Inicializa tabelas do banco de dados."""
        with self._get_connection() as conn:
            cursor = conn.cursor()
            
            # Tabela de contadores de código
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS code_counters (
                    prefix TEXT PRIMARY KEY,
                    last_value INTEGER NOT NULL DEFAULT 0,
                    category_id INTEGER,
                    category_name TEXT,
                    updated_at TEXT NOT NULL
                )
            """)
            
            # Tabela de eventos processados (idempotência webhook)
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS processed_events (
                    event_id TEXT PRIMARY KEY,
                    event_type TEXT NOT NULL,
                    product_id INTEGER,
                    processed_at TEXT NOT NULL,
                    payload TEXT
                )
            """)
            
            # Índices
            cursor.execute("""
                CREATE INDEX IF NOT EXISTS idx_events_product 
                ON processed_events(product_id)
            """)
            
            cursor.execute("""
                CREATE INDEX IF NOT EXISTS idx_events_type 
                ON processed_events(event_type)
            """)
    
    def get_next_code(self, prefix, category_id=None, category_name=None):
        """
        Obtém o próximo código sequencial para um prefixo.
        Thread-safe via transação SQLite.
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            
            # Tenta incrementar existente
            cursor.execute("""
                UPDATE code_counters 
                SET last_value = last_value + 1,
                    updated_at = ?
                WHERE prefix = ?
            """, (datetime.now().isoformat(), prefix))
            
            # Se não existia, cria
            if cursor.rowcount == 0:
                cursor.execute("""
                    INSERT INTO code_counters 
                    (prefix, last_value, category_id, category_name, updated_at)
                    VALUES (?, 1, ?, ?, ?)
                """, (prefix, category_id, category_name, datetime.now().isoformat()))
                return f"{prefix}00001"
            
            # Busca valor atualizado
            cursor.execute(
                "SELECT last_value FROM code_counters WHERE prefix = ?",
                (prefix,)
            )
            row = cursor.fetchone()
            return f"{prefix}{row['last_value']:05d}"
    
    def get_last_code_value(self, prefix):
        """Retorna o último valor usado para um prefixo."""
        with self._get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(
                "SELECT last_value FROM code_counters WHERE prefix = ?",
                (prefix,)
            )
            row = cursor.fetchone()
            return row['last_value'] if row else 0
    
    def is_event_processed(self, event_id):
        """Verifica se um evento webhook já foi processado."""
        with self._get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(
                "SELECT 1 FROM processed_events WHERE event_id = ? LIMIT 1",
                (event_id,)
            )
            return cursor.fetchone() is not None
    
    def mark_event_processed(self, event_id, event_type, product_id=None, payload=None):
        """Marca um evento como processado."""
        with self._get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT OR IGNORE INTO processed_events 
                (event_id, event_type, product_id, processed_at, payload)
                VALUES (?, ?, ?, ?, ?)
            """, (
                event_id,
                event_type,
                product_id,
                datetime.now().isoformat(),
                json.dumps(payload) if payload else None
            ))
    
    def get_stats(self):
        """Retorna estatísticas do banco."""
        with self._get_connection() as conn:
            cursor = conn.cursor()
            
            cursor.execute("SELECT COUNT(*) as count FROM code_counters")
            counters_count = cursor.fetchone()['count']
            
            cursor.execute("SELECT COUNT(*) as count FROM processed_events")
            events_count = cursor.fetchone()['count']
            
            cursor.execute("""
                SELECT prefix, last_value, category_name, updated_at 
                FROM code_counters 
                ORDER BY updated_at DESC 
                LIMIT 10
            """)
            recent_counters = [dict(row) for row in cursor.fetchall()]
            
            return {
                'counters': counters_count,
                'events': events_count,
                'recent_counters': recent_counters
            }

```

```
File: D:\Projects\bling_monitor\bling_utils.py
"""
Funções utilitárias compartilhadas entre módulos
"""
from datetime import datetime, timedelta


class CategoryCache:
    """Cache de categorias carregadas da API."""
    
    def __init__(self):
        self._categories = {}  # ID -> categoria completa
        self._loaded = False
    
    def load(self, api):
        """Carrega todas as categorias da API."""
        if self._loaded:
            return
        
        print("Carregando cache de categorias...")
        self._categories = api.get_all_categories()
        self._loaded = True
        print(f"✅ {len(self._categories)} categorias em cache")
    
    def get_by_id(self, category_id):
        """Obtém categoria por ID."""
        return self._categories.get(category_id)
    
    def get_name(self, category_id):
        """Obtém nome da categoria por ID."""
        cat = self._categories.get(category_id)
        
        if not cat:
            ''
        if cat.get('nome', ''):
            return cat.get('nome', '')
        
        if cat.get('descricao', ''):
            return cat.get('descricao', '')
        
        return ''
    
    def is_loaded(self):
        """Verifica se cache foi carregado."""
        return self._loaded


# Instância global do cache
_category_cache = CategoryCache()


def get_category_cache():
    """Retorna a instância global do cache."""
    return _category_cache


def extract_category_info(product, category_cache=None):
    """
    Extrai categoria e subcategoria de um produto.
    
    Args:
        product: Dicionário do produto
        category_cache: Instância de CategoryCache (opcional)
    
    Returns:
        (category_name, subcategory_name, full_hierarchy, category_id)
    """
    cat_info = product.get('categoria', {})
    cat_id = cat_info.get('id')
    
    if not cat_id:
        return None, None, None, None
    
    # Tentar obter nome do cache primeiro
    if category_cache:
        full_name = category_cache.get_name(cat_id)
    else:
        # Fallback: tentar obter do próprio produto (pode não existir)
        full_name = cat_info.get('nome', '')
    
    if not full_name:
        return None, None, None, cat_id
    
    # Extrair hierarquia (Categoria>>Subcategoria)
    if '>>' in full_name:
        parts = full_name.split('>>')
        category = parts[0].strip()
        subcategory = parts[-1].strip()
        return category, subcategory, full_name, cat_id
    else:
        return full_name, None, full_name, cat_id


def should_ignore_product(product, category_cache=None,
                         excluded_categories={'notebook', 'sff', 'mini', 'monitor'}, 
                         ignore_subcategories={'submaquina'}):
    """
    Verifica se produto deve ser ignorado baseado em categoria.
    
    Args:
        product: Dicionário do produto
        category_cache: Instância de CategoryCache
        excluded_categories: Set de categorias a excluir (lowercase)
        ignore_subcategories: Set de subcategorias a ignorar (lowercase)
    
    Returns:
        (should_ignore: bool, reason: str)
    """
    category, subcategory, full, cat_id = extract_category_info(product, category_cache)
    
    if not category:
        return False, "Sem categoria ou categoria não encontrada no cache"
    
    # Verificar categorias excluídas
    if category.lower() in excluded_categories:
        return True, f"Categoria excluída: {category}"
    
    # Verificar subcategorias ignoradas
    if subcategory and subcategory.lower() in ignore_subcategories:
        return True, f"Subcategoria ignorada: {subcategory}"
    
    return False, ""


def check_stock_depleted_by_sales(api, product_id):
    """
    Verifica se o estoque zerou ESPECIFICAMENTE por vendas.
    
    Args:
        api: Instância de BlingAPI
        product_id: ID do produto
    
    Returns:
        (is_depleted_by_sales: bool, details: dict)
    """
    try:
        # Buscar movimentações dos últimos 365 dias
        end_date = datetime.now().strftime('%Y-%m-%d')
        start_date = (datetime.now() - timedelta(days=365)).strftime('%Y-%m-%d')
        
        response = api.get_stock_movements(
            product_id,
            start_date=start_date,
            end_date=end_date
        )
        
        movements = response.get('data', [])
        
        if not movements:
            return False, {
                'reason': 'Sem movimentacoes (nunca teve entrada)',
                'entries': 0,
                'sales_exits': 0
            }
        
        total_entries = 0
        total_sales_exits = 0
        
        for mov in movements:
            quantidade = mov.get('quantidade', 0)
            tipo = mov.get('tipo', '')
            operacao = mov.get('operacao', '').lower()
            
            if tipo == 'E':  # Entrada
                total_entries += quantidade
            
            elif tipo == 'S':  # Saída
                # Verificar se é saída por venda
                if any(keyword in operacao for keyword in ['venda', 'pedido', 'nfe', 'nota fiscal']):
                    total_sales_exits += quantidade
        
        # Critério: teve entradas E elas foram totalmente consumidas por vendas
        if total_entries > 0 and total_entries == total_sales_exits:
            return True, {
                'reason': 'Estoque zerado por vendas',
                'entries': total_entries,
                'sales_exits': total_sales_exits
            }
        
        return False, {
            'reason': 'Entradas nao batem com saidas por venda' if total_entries > 0 else 'Sem entradas',
            'entries': total_entries,
            'sales_exits': total_sales_exits
        }
    
    except Exception as e:
        print(f"    Erro ao verificar movimentacoes: {e}")
        return False, {'reason': f'Erro: {e}', 'entries': 0, 'sales_exits': 0}


def get_category_prefix(category_name):
    """
    Gera prefixo de código baseado no nome da categoria.
    
    Exemplos:
        "Teclado Mouse" -> "TEMO"
        "Placa Mae" -> "PLMA"
        "Monitor" -> "MONI"
    """
    # Remove acentos comuns
    replacements = {
        'ã': 'a', 'á': 'a', 'à': 'a', 'â': 'a',
        'é': 'e', 'ê': 'e',
        'í': 'i',
        'õ': 'o', 'ó': 'o', 'ô': 'o',
        'ú': 'u', 'ü': 'u',
        'ç': 'c'
    }
    
    clean_name = category_name.lower()
    for old, new in replacements.items():
        clean_name = clean_name.replace(old, new)
    
    parts = clean_name.split()
    
    if len(parts) > 1:
        # Pega 2 primeiras letras de cada palavra
        return (parts[0][:2] + parts[1][:2]).upper()
    else:
        # Pega 4 primeiras letras
        return clean_name[:4].upper()


def should_generate_code(product, category_cache=None):
    """
    Verifica se deve gerar código para o produto.
    
    Args:
        product: Dicionário do produto
        category_cache: Instância de CategoryCache
    
    Returns:
        (should_generate: bool, reason: str, prefix: str)
    """
    # Já tem código?
    if product.get('codigo'):
        return False, "Ja possui codigo", None
    
    category, subcategory, full, cat_id = extract_category_info(product, category_cache)
    
    if not category:
        return False, "Sem categoria ou categoria nao encontrada", None
    
    # SubMaquina: ignorar
    if subcategory and subcategory.lower() == 'submaquina':
        return False, "Subcategoria SubMaquina (ignorar)", None
    
    if category.lower() == 'submaquina':
        return False, "Categoria SubMaquina (ignorar)", None
    
    # Notebook, Mini, SFF -> NTB
    if category.lower() in ['notebook', 'mini', 'sff']:
        return True, f"Categoria {category}", "NTB"
    
    # Peças: usar subcategoria (CORRIGIDO - sem encoding corrompido)
    if category.lower() in ['pecas', 'peca'] or 'peca' in category.lower():
        if subcategory:
            prefix = get_category_prefix(subcategory)
            return True, f"Peca - Subcategoria {subcategory}", prefix
        else:
            return False, "Peca sem subcategoria", None
    
    # Outras categorias: gera prefixo da categoria
    prefix = get_category_prefix(category)
    return True, f"Categoria {category}", prefix
```

```
File: D:\Projects\bling_monitor\dump_products.py
"""
Script de geração de códigos para produtos - COM PERSISTÊNCIA
"""
import json
from datetime import datetime

# Imports dos novos módulos
from bling_auth import ensure_authenticated
from bling_api import BlingAPI
from bling_db import BlingDatabase
from bling_utils import (
    get_category_cache,
    extract_category_info,
    should_generate_code
)

# Cliente API e Database
api = BlingAPI(ensure_authenticated)
db = BlingDatabase()

# Cache de categorias (NOVO)
category_cache = get_category_cache()

OUTPUT_FILE = "products_dump.json"


def generate_and_update_code(product, product_details):
    """
    Gera código e atualiza produto na API.
    
    Returns:
        (success: bool, code: str or None, message: str)
    """
    product_id = product['id']
    
    # Passa o cache para should_generate_code (ATUALIZADO)
    should_gen, reason, prefix = should_generate_code(product_details, category_cache)
    
    if not should_gen:
        return False, None, reason
    
    # Gerar código usando banco de dados (thread-safe)
    category, subcategory, full, cat_id = extract_category_info(product_details, category_cache)
    new_code = db.get_next_code(
        prefix=prefix,
        category_id=cat_id,
        category_name=full
    )
    
    print(f"   🏷️  Código gerado: {new_code}")
    
    # Atualizar na API
    try:
        api.update_product(product_id, {"codigo": new_code})
        return True, new_code, f"Atualizado com sucesso ({reason})"
    except Exception as e:
        return False, None, f"Erro ao atualizar: {e}"


def process_product_variations(product_details):
    """
    Processa variações de produto (se houver).
    """
    variations = product_details.get('variacoes', [])
    
    if not variations:
        return
    
    print(f"   🔀 Produto tem {len(variations)} variações")
    
    for var in variations:
        var_id = var.get('id')
        var_name = var.get('nome', 'Sem nome')
        var_code = var.get('codigo')
        
        if var_code:
            print(f"      ⏭️  Variação {var_id} já tem código: {var_code}")
            continue
        
        print(f"      🔍 Processando variação: {var_name}")
        
        # Variações herdam categoria do produto pai
        should_gen, reason, prefix = should_generate_code(product_details, category_cache)
        
        if not should_gen:
            print(f"      ⏭️  {reason}")
            continue
        
        # Gerar código
        category, subcategory, full, cat_id = extract_category_info(product_details, category_cache)
        new_code = db.get_next_code(
            prefix=prefix,
            category_id=cat_id,
            category_name=full
        )
        
        print(f"      🏷️  Código gerado para variação: {new_code}")
        
        # Atualizar variação
        try:
            api.update_product(var_id, {"codigo": new_code})
            var['codigo'] = new_code
            print("      ✅ Variação atualizada com sucesso")
        except Exception as e:
            print(f"      ❌ Erro ao atualizar variação: {e}")


def dump_and_update_product_codes():
    """
    Varre todos os produtos, gera códigos e atualiza na API.
    """
    print(f"\n{'='*80}")
    print(f"🚀 INICIANDO GERAÇÃO DE CÓDIGOS - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"{'='*80}\n")
    
    # Carregar cache de categorias (NOVO - CRÍTICO!)
    category_cache.load(api)
    
    all_products = []
    page = 1
    total_processed = 0
    total_updated = 0
    total_skipped = 0
    total_errors = 0
    
    while True:
        try:
            data = api.get_products(page=page, limit=100)
            products = data.get("data", [])
            
            if not products:
                break
            
            print(f"\n{'─'*80}")
            print(f"📄 Processando página {page} ({len(products)} produtos)")
            print(f"{'─'*80}\n")
            
            for product_summary in products:
                total_processed += 1
                product_id = product_summary['id']
                product_name = product_summary.get('nome', 'Sem nome')
                
                print(f"\n[{total_processed}] 📦 {product_name}")
                print(f"    ID: {product_id}")
                
                # Buscar detalhes completos
                try:
                    details_response = api.get_product(product_id)
                    product_details = details_response.get('data', {})
                except Exception as e:
                    print(f"    ❌ Erro ao buscar detalhes: {e}")
                    total_errors += 1
                    all_products.append(product_summary)
                    continue
                
                # Gerar e atualizar código
                success, code, message = generate_and_update_code(product_summary, product_details)
                
                if success:
                    print(f"    ✅ {message}")
                    product_details['codigo'] = code
                    total_updated += 1
                else:
                    print(f"    ⏭️  {message}")
                    total_skipped += 1
                
                # Processar variações
                process_product_variations(product_details)
                
                all_products.append(product_details)
            
            page += 1
        
        except Exception as e:
            print(f"\n❌ Erro na página {page}: {e}")
            break
    
    # Salvar dump
    print(f"\n💾 Salvando dump em {OUTPUT_FILE}...")
    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        json.dump(all_products, f, ensure_ascii=False, indent=2)
    
    # Relatório final
    print(f"\n{'='*80}")
    print("📊 RELATÓRIO FINAL")
    print(f"{'='*80}")
    print(f"✅ Produtos processados: {total_processed}")
    print(f"🏷️  Códigos gerados e atualizados: {total_updated}")
    print(f"⏭️  Ignorados (já tinham código/regra): {total_skipped}")
    print(f"❌ Erros: {total_errors}")
    print(f"💾 Dump salvo: {OUTPUT_FILE}")
    print(f"{'='*80}\n")
    
    # Estatísticas do banco
    stats = db.get_stats()
    print("📊 ESTATÍSTICAS DO BANCO DE DADOS")
    print(f"{'='*80}")
    print(f"Contadores de código cadastrados: {stats['counters']}")
    print("\nÚltimos contadores usados:")
    for counter in stats['recent_counters'][:5]:
        print(f"  • {counter['prefix']}: {counter['last_value']:05d} ({counter['category_name']})")
    print(f"{'='*80}\n")


if __name__ == "__main__":
    dump_and_update_product_codes()
```

```
File: D:\Projects\bling_monitor\quick_test.py
"""
Script de teste rápido para validar módulos
"""
from bling_auth import ensure_authenticated
from bling_api import BlingAPI
from bling_db import BlingDatabase

def test_auth():
    """Testa autenticação."""
    print("🔑 Testando autenticação...")
    try:
        token = ensure_authenticated()
        print(f"✅ Token obtido: {token[:20]}...")
        return True
    except Exception as e:
        print(f"❌ Erro: {e}")
        return False

def test_api():
    """Testa chamada à API."""
    print("\n📡 Testando API...")
    try:
        api = BlingAPI(ensure_authenticated)
        data = api.get_products(page=1, limit=1)
        products = data.get('data', [])
        print(f"✅ API funcionando. {len(products)} produto(s) retornado(s)")
        return True
    except Exception as e:
        print(f"❌ Erro: {e}")
        return False

def test_database():
    """Testa banco de dados."""
    print("\n💾 Testando banco de dados...")
    try:
        db = BlingDatabase()
        
        # Testa geração de código
        code1 = db.get_next_code("TEST", category_id=999, category_name="Teste")
        code2 = db.get_next_code("TEST", category_id=999, category_name="Teste")
        
        assert code1 == "TEST00001", f"Código esperado TEST00001, obtido {code1}"
        assert code2 == "TEST00002", f"Código esperado TEST00002, obtido {code2}"
        
        # Testa idempotência
        db.mark_event_processed("test_event_123", "product.created", 999, {"test": True})
        assert db.is_event_processed("test_event_123"), "Evento deveria estar marcado"
        assert not db.is_event_processed("test_event_999"), "Evento não deveria estar marcado"
        
        print("✅ Banco funcionando corretamente")
        
        # Mostra stats
        stats = db.get_stats()
        print("\n📊 Estatísticas:")
        print(f"   Contadores: {stats['counters']}")
        print(f"   Eventos: {stats['events']}")
        
        return True
    except Exception as e:
        print(f"❌ Erro: {e}")
        return False

if __name__ == "__main__":
    print("="*60)
    print("🧪 TESTE DE VALIDAÇÃO DOS MÓDULOS")
    print("="*60 + "\n")
    
    results = {
        "Autenticação": test_auth(),
        "API": test_api(),
        "Database": test_database()
    }
    
    print("\n" + "="*60)
    print("📊 RESULTADO DOS TESTES")
    print("="*60)
    
    for test, passed in results.items():
        status = "✅ PASSOU" if passed else "❌ FALHOU"
        print(f"{test}: {status}")
    
    all_passed = all(results.values())
    
    print("="*60)
    if all_passed:
        print("🎉 TODOS OS TESTES PASSARAM!")
    else:
        print("⚠️  ALGUNS TESTES FALHARAM")
    print("="*60)

```

```
File: D:\Projects\bling_monitor\requirements.txt
requests==2.31.0
python-dotenv==1.0.0
flask==3.0.0

```

```
File: D:\Projects\bling_monitor\test.py
"""
Script de monitoramento contínuo - Desativa produtos com estoque zerado POR VENDAS
"""
import time
from datetime import datetime
from dotenv import load_dotenv
import os

# Imports dos novos módulos
from bling_auth import ensure_authenticated
from bling_api import BlingAPI
from bling_utils import (
    get_category_cache,
    should_ignore_product,
    check_stock_depleted_by_sales
)

load_dotenv()

# Configurações
MINUTES_BETWEEN_RUNS = int(os.getenv("MINUTES_BETWEEN_RUNS", 60))
EXCLUDED_CATEGORIES = {"notebook", "sff", "mini", "monitor"}
IGNORE_SUBCATEGORIES = {"submaquina"}

# Cliente API
api = BlingAPI(ensure_authenticated)

# Cache de categorias (NOVO)
category_cache = get_category_cache()


def process_zero_stock_products():
    """
    Processa produtos com estoque zero, desativando apenas os que zeraram por vendas.
    """
    print(f"\n{'='*80}")
    print(f"🔍 INICIANDO VARREDURA - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"{'='*80}\n")
    
    # Carregar cache de categorias (NOVO - só carrega uma vez)
    if not category_cache.is_loaded():
        category_cache.load(api)
    
    page = 1
    checked_count = 0
    zero_stock_count = 0
    deactivated_count = 0
    ignored_count = 0
    
    while True:
        try:
            data = api.get_products(page=page, limit=100)
            products = data.get("data", [])
            
            if not products:
                break
            
            for p in products:
                checked_count += 1
                stock = p.get("estoqueAtual", 0)
                
                if stock != 0:
                    continue
                
                zero_stock_count += 1
                product_id = p.get("id")
                product_name = p.get("nome", "Sem nome")
                
                print("\n📦 Produto com estoque ZERO encontrado:")
                print(f"   ID: {product_id}")
                print(f"   Nome: {product_name}")
                
                # Buscar detalhes completos
                try:
                    details_response = api.get_product(product_id)
                    product_details = details_response.get("data", {})
                except Exception as e:
                    print(f"   ❌ Erro ao buscar detalhes: {e}")
                    continue
                
                # Verificar se deve ignorar (ATUALIZADO - passa o cache)
                should_ignore, ignore_reason = should_ignore_product(
                    product_details, 
                    category_cache,
                    EXCLUDED_CATEGORIES,
                    IGNORE_SUBCATEGORIES
                )
                
                if should_ignore:
                    ignored_count += 1
                    print(f"   ⏭️  IGNORADO: {ignore_reason}")
                    continue
                
                # Verificar se zerou por vendas
                print("   🔍 Verificando movimentações de estoque...")
                is_depleted, details = check_stock_depleted_by_sales(api, product_id)
                
                print(f"   📊 Entradas: {details['entries']}")
                print(f"   📊 Saídas por venda: {details['sales_exits']}")
                print(f"   📊 Motivo: {details['reason']}")
                
                if is_depleted:
                    print("   🔴 DESATIVANDO produto...")
                    try:
                        api.update_product_situation(product_id, 'I')
                        deactivated_count += 1
                        print("   ✅ Produto DESATIVADO com sucesso")
                    except Exception as e:
                        print(f"   ❌ Erro ao desativar: {e}")
                else:
                    print("   ✅ Produto NÃO será desativado (não zerou por vendas)")
            
            print(f"\n📄 Página {page} processada ({len(products)} produtos)")
            page += 1
        
        except Exception as e:
            print(f"\n❌ Erro na página {page}: {e}")
            break
    
    # Relatório final
    print(f"\n{'='*80}")
    print("📊 RELATÓRIO FINAL")
    print(f"{'='*80}")
    print(f"✅ Produtos verificados: {checked_count}")
    print(f"⚠️  Com estoque zero: {zero_stock_count}")
    print(f"⏭️  Ignorados (categoria): {ignored_count}")
    print(f"🔴 Desativados (zerado por vendas): {deactivated_count}")
    print(f"{'='*80}\n")


def main():
    """Loop principal."""
    print("🚀 Iniciando monitoramento Bling...")
    print(f"⏱️  Intervalo entre execuções: {MINUTES_BETWEEN_RUNS} minutos\n")
    
    try:
        while True:
            process_zero_stock_products()
            
            print(f"⏳ Aguardando {MINUTES_BETWEEN_RUNS} minutos até próxima execução...")
            print("   (Pressione Ctrl+C para interromper)\n")
            
            time.sleep(MINUTES_BETWEEN_RUNS * 60)
    
    except KeyboardInterrupt:
        print("\n\n🛑 Script interrompido pelo usuário. Encerrando...")


if __name__ == "__main__":
    main()
```

```
File: D:\Projects\bling_monitor\test.spec
# -*- mode: python ; coding: utf-8 -*-


a = Analysis(
    ['test.py'],
    pathex=[],
    binaries=[],
    datas=[],
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='test',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=True,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
)

```

```
File: D:\Projects\bling_monitor\webhook_server.py
"""
Servidor de webhooks Bling com validação HMAC e processamento assíncrono
"""
from flask import Flask, request, jsonify
import hmac
import hashlib
import os
import threading
import queue
from dotenv import load_dotenv

from bling_auth import ensure_authenticated
from bling_api import BlingAPI
from bling_db import BlingDatabase
from bling_utils import (
    should_ignore_product, 
    check_stock_depleted_by_sales,
    should_generate_code,
    extract_category_info
)

load_dotenv()

app = Flask(__name__)

# Configurações
CLIENT_SECRET = os.getenv("CLIENT_SECRET")
WEBHOOK_PORT = int(os.getenv("WEBHOOK_PORT", 5000))

# Recursos
api = BlingAPI(ensure_authenticated)
db = BlingDatabase()

# Fila de eventos
event_queue = queue.Queue()


def verify_hmac_signature(payload_bytes, signature):
    """
    Verifica assinatura HMAC-SHA256 do webhook.
    
    Args:
        payload_bytes: Corpo da requisição (bytes brutos)
        signature: Header X-Bling-Signature-256
    
    Returns:
        bool
    """
    expected = 'sha256=' + hmac.new(
        CLIENT_SECRET.encode('utf-8'),
        payload_bytes,
        hashlib.sha256
    ).hexdigest()
    
    return hmac.compare_digest(signature, expected)


@app.route('/webhook/bling', methods=['POST'])
def webhook_handler():
    """
    Endpoint principal de recepção de webhooks.
    DEVE responder em < 5 segundos.
    """
    # Validar assinatura HMAC
    signature = request.headers.get('X-Bling-Signature-256', '')
    
    if not verify_hmac_signature(request.get_data(), signature):
        print("❌ Assinatura HMAC inválida!")
        return jsonify({"error": "Invalid signature"}), 401
    
    # Parsear payload
    try:
        payload = request.get_json()
    except Exception as e:
        print(f"❌ Erro ao parsear JSON: {e}")
        return jsonify({"error": "Invalid JSON"}), 400
    
    event_id = payload.get('eventId')
    event_type = payload.get('event')
    
    if not event_id or not event_type:
        print("❌ Payload sem eventId ou event")
        return jsonify({"error": "Missing eventId or event"}), 400
    
    # Verificar idempotência
    if db.is_event_processed(event_id):
        print(f"ℹ️  Evento {event_id} já processado anteriormente (idempotência)")
        return jsonify({"status": "already_processed"}), 200
    
    # Enfileirar para processamento assíncrono
    event_queue.put(payload)
    
    print(f"✅ Webhook recebido: {event_type} (eventId: {event_id})")
    
    # Responder rapidamente (<5s)
    return jsonify({"status": "queued"}), 200


@app.route('/health', methods=['GET'])
def health_check():
    """Endpoint de health check."""
    stats = db.get_stats()
    return jsonify({
        "status": "healthy",
        "queue_size": event_queue.qsize(),
        "db_stats": stats
    }), 200


def process_stock_event(data):
    """Processa evento de estoque (stock.updated)."""
    
    product_info = data.get('produto', {})
    product_id = product_info.get('id')
    
    if not product_id:
        print("⚠️  Evento de estoque sem ID de produto")
        return
    
    print(f"📦 Processando evento de estoque para produto {product_id}")
    
    try:
        # Buscar produto completo
        response = api.get_product(product_id)
        product = response.get('data', {})
        
        # Verificar se deve ignorar
        should_ignore, reason = should_ignore_product(product)
        if should_ignore:
            print(f"   ⏭️  {reason}")
            return
        
        # Verificar estoque
        stock = product.get('estoque', {}).get('saldoVirtualTotal', 0)
        
        if stock > 0:
            print("   ✅ Estoque > 0, nada a fazer")
            return
        
        # Verificar se zerou por vendas
        is_depleted, details = check_stock_depleted_by_sales(api, product_id)
        
        if is_depleted:
            print("   🔴 Desativando produto (zerado por vendas)")
            api.update_product_situation(product_id, 'I')
            print("   ✅ Produto desativado")
        else:
            print(f"   ℹ️  Não desativar: {details['reason']}")
    
    except Exception as e:
        print(f"   ❌ Erro ao processar: {e}")


def process_product_event(data):
    """Processa evento de produto (product.created, product.updated)."""
    
    product_id = data.get('id')
    
    if not product_id:
        print("⚠️  Evento de produto sem ID")
        return
    
    print(f"📦 Processando evento de produto {product_id}")
    
    try:
        # Se já tem código, ignora
        if data.get('codigo'):
            print(f"   ℹ️  Produto já possui código: {data.get('codigo')}")
            return
        
        # Buscar detalhes completos
        response = api.get_product(product_id)
        product = response.get('data', {})
        
        # Verificar se deve gerar código
        should_gen, reason, prefix = should_generate_code(product)
        
        if not should_gen:
            print(f"   ⏭️  {reason}")
            return
        
        # Gerar código
        category, subcategory, full, cat_id = extract_category_info(product)
        new_code = db.get_next_code(
            prefix=prefix,
            category_id=cat_id,
            category_name=full
        )
        
        print(f"   🏷️  Gerando código: {new_code}")
        
        # Atualizar produto
        api.update_product(product_id, {"codigo": new_code})
        print("   ✅ Código atribuído com sucesso")
    
    except Exception as e:
        print(f"   ❌ Erro ao processar: {e}")


def event_processor_worker():
    """Thread worker que processa eventos da fila."""
    print("🔄 Worker de processamento iniciado")
    
    while True:
        try:
            # Pega evento da fila (bloqueante)
            payload = event_queue.get(timeout=1)
            
            event_id = payload.get('eventId')
            event_type = payload.get('event')
            data = payload.get('data', {})
            
            print(f"\n{'─'*60}")
            print(f"🔄 Processando evento: {event_type} (ID: {event_id})")
            print(f"{'─'*60}")
            
            # Marcar como processado
            product_id = data.get('id') or data.get('produto', {}).get('id')
            db.mark_event_processed(event_id, event_type, product_id, payload)
            
            # Rotear para processador específico
            if event_type == 'stock.updated':
                process_stock_event(data)
            
            elif event_type in ['product.created', 'product.updated']:
                process_product_event(data)
            
            else:
                print(f"⚠️  Tipo de evento desconhecido: {event_type}")
            
            event_queue.task_done()
            print("✅ Evento processado com sucesso\n")
        
        except queue.Empty:
            continue
        
        except Exception as e:
            print(f"❌ Erro ao processar evento: {e}\n")


def start_server():
    """Inicia servidor de webhooks."""
    print(f"\n{'='*80}")
    print("🚀 INICIANDO SERVIDOR DE WEBHOOKS BLING")
    print(f"{'='*80}")
    print("🌐 Host: 0.0.0.0")
    print(f"🔌 Porta: {WEBHOOK_PORT}")
    print("📍 Endpoint: http://your-domain.com/webhook/bling")
    print("❤️  Health: http://your-domain.com/health")
    print(f"{'='*80}\n")
    
    # Iniciar worker thread
    worker_thread = threading.Thread(target=event_processor_worker, daemon=True)
    worker_thread.start()
    
    # Iniciar Flask
    app.run(
        host='0.0.0.0',
        port=WEBHOOK_PORT,
        debug=False,
        threaded=True
    )


if __name__ == '__main__':
    start_server()

```

